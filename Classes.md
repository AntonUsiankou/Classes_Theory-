**Theory**

**Questions**

**Какие уровни доступа есть у класса на верхнем уровне, т.е. у внешнего класса?**

**Ответ.** public, package-private (уровень доступа по умолчанию).
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html

**Что является членами класса?**

**Ответ.** Поля - переменные, относящиеся к классу и его объектам и в совокупности определяющие состояние класса или конкретного объекта.
Методы (methods) – именованные фрагменты исполняемого кода класса, обусловливающие особенности поведения объектов класса.
Вложенные классы и вложенные интерфейсы первого уровня – объявления классов или интерфейсов, размещенные в тексте объявлений других классов или интерфейсов.
**Источник.** https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.6
 
**Что еще можно определить в классе кроме членов?**

**Ответ.** Конструкторы, статические и логические блоки.
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/classes.html
https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html

**Какие уровни доступа есть у членов класса?**

**Ответ.** В Java используются следующие модификаторы доступа:
●   	public: публичный, общедоступный член класса. Поля и методы, объявленные с модификатором public, видны другим классам из текущего пакета и из внешних пакетов.
●   	private: закрытый член класса, противоположность модификатору public. Закрытый член класса доступен только из кода в том же классе.
●   	protected: такой член класса доступен из любого места в текущем классе или пакете или в производных классах, даже если они находятся в других пакетах
●   	package-private: отсутствие модификатора у поля или метода класса предполагает применение к нему модификатора по умолчанию. Такие поля или методы видны всем классам в текущем пакете.

**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html

**Какие модификаторы необходимы для определения константы:
1. класса,
2. экземпляра класса?**

**Ответ.** 1. [модификатор доступа] final static.
2. [модификатор доступа] final.

**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html

**Обратный вопрос. Допустим, у некоторого класса есть 4 следующих поля:
class SomeClass {
	private int a;
	private final int b;
private static int c;
private static final int D;
...
} 
Как можно назвать данные поля в зависимости от комбинации модификаторов static и final?**

**Ответ.**   private final int b; // константа экземпляра класса
 private static final int D; // константа класса
 private static int c; // переменная класса
 private int a; // переменная экземпляра класса
 
Может ли класс не иметь ни одного конструктора? Почему?

**Ответ:**  Если в классе (в java коде, т.е. до трансляции) не определен ни один конструктор, Java предоставляет конструктор по умолчанию (в байт коде, т.е. после трансляции), который инициализирует объект значениями по умолчанию и вызывает конструктор без параметров суперкласса.
Но если в классе есть хотя бы один конструктор, то транслятор не будет создавать конструктор по умолчанию.
Пример:
class Car {
 	private int cost;
 	private String name;

 	/* будет создан конструктор
 	public Car() {
       	super();
 	}
 	*/
}

**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html

Перечислите отличия конструктора от метода.

**Ответ.**
Свойство	Конструкторы	Методы
Назначение	Создает экземпляр класса	Группирует операторы Java
Модификаторы	Не может быть abstract, final, native,static, или synchronized	Может быть abstract, final, native,static, или synchronized
Возвращаемый тип	Нет возвращаемого типа, не может быть даже void	void или любой корректный тип
Имя	Такое же как и имя класса.	Любое имя.
this	Ссылается на другой конструктор в этом же классе. Если используется, то обращение должно к нему быть первой строкой конструктора	Ссылается на экземпляр класса-владельца. Не может использоваться статическими методами
super	Вызывает конструктор родительского класса. Если используется, должно обращение к нему быть первой строкой конструктора	Вызывает какой-либо переопределенный метод в родительском классе
Наследование	Конструкторы не наследуются	Методы наследуются
Автоматическое добавление кода конструктора компилятором	Если в классе не описан конструктор, компилятор автоматически добавляет в код конструктор без параметров	Отсутствует
Автоматическое добавление компилятором вызова конструктора класса-предка	Если конструктор не делает вызов конструктора super класса-предка (с аргументами или без аргументов), компилятор автоматически добавляет код вызова конструктора класса-предка без аргументов	Отсутствует

**Источник.** http://www.strongexperts.narod.ru/ru/articles/archive/java2/2006/jun2006-001/jun2006-001.htm

Как и в каком месте можно вызвать из одного конструктора другой конструктор этого же класса?

**Ответ.** С помощью ключевого слова this(список_аргументов), где список_аргументов - список аргументов вызываемого конструктора этого же класса. Причем данное ключевое слово должно всегда идти первым оператором в теле конструктора.

**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html

Как и в каком месте можно вызвать конструктор суперкласса?

**Ответ.** С помощью ключевого слова super(список_аргументов), где список_аргументов - список аргументов вызываемого конструктора суперкласса. Причем данное ключевое слово должно всегда идти первым оператором в теле конструктора.

**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/super.html

Что делает компилятор, если в конструкторе нет вызова другого конструктора или конструктора суперкласса?

**Ответ.** Будет подставлено ключевое слово super(), которое будет вызывать конструктор без параметров суперкласса.
Если класс не содержит явного extends, то будет вызван конструктор без параметров глобального суперкласса Object.
Если у суперкласса нет конструктора без аргументов, то будет ошибка компиляции.

**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/super.html

Можно ли одновременно использовать конструкции this() и super() в одном и том же конструкторе?
Обоснуйте ответ.

**Ответ.** Нет, в теле конструктора первым оператором должна идти конструкция this()/super(), поэтому 2-го вызова быть не может. Если такое было бы возможно, то возможно было вызвать конструктор суперкласса 2 раза, что не имеет смысла.
Источник.https://javarush.ru/groups/posts/1187-raznica-mezhdu-kljuchevihmi-slovami-this-i-super-v-java
Может ли быть приватный уровень доступа у конструктора? Если да, то для каких целей он необходим?
Ответ: Да, конструктор может быть закрытым. Это разные способы использования. Одно из таких применений для singleton design anti-pattern, которое я бы посоветовал вам использовать. Другое, более законное использование - это делегирование конструкторов; у вас может быть один конструктор, который принимает множество различных опций, которые действительно являются деталями реализации, поэтому вы делаете их закрытыми, но затем ваши остальные конструкторы делегируют ему.

**Источник.** https://fooobar.com/questions/36342/can-a-constructor-in-java-be-private

Какие модификаторы может иметь конструктор?

**Ответ:** 
•	В конструкторе допускается применение модификаторов доступа, можно задать один из модификаторов: public, protected, private или без модификатора.
•	Конструктор не может иметь модификаторов abstract, final, native, static или synchronized;

**Источник.** https://javarush.ru/groups/posts/1391-konstruktorih-klassov-java-jdk-15

Конструктор принадлежит классу или экземпляру класса?

**Ответ.** Конструктор принадлежит классу, но вызывается в контексте экземпляра класса.

**Источник.** https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.8.3

Можно ли наследовать конструктор?
Если да, то приведите примеры. 

**Ответ.** Нет, конструкторы не являются членами класса, поэтому не наследуются. Можно лишь вызвать конструктор суперкласса посредством super().

**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html

Какой тип возвращаемого конструктором значения?

**Ответ:** Конструкторы не имеют возвращаемого типа.

**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html

Дан класс.
class Null {
	//фрагмент 1
	Null Null() {
		return null;
	}
	//фрагмент 2
	Null() {
		return null;
	}
}
В каком фрагменте ошибка компиляции? 
Удалите этот фрагмент полностью. 
Прокомментируйте оставшийся фрагмент и продемонстрируйте функционал класса. 

**Ответ.**
class Null {
 	//фрагмент 1
 	Null Null() {
   		return null;
 	}
}
Ошибка компиляции во 2-м фрагменте, т. к. конструктор не может иметь возвращаемого значения. Фрагмент 1 – метод экземпляра класса, который возвращает значение null:
public static void main(String[] args) {
    	   Null object = new Null();
    	   object = object.Null();
    	   System.out.println(object); // null
}
 
 
Если метод имеет то же имя, как и класс, то каким образом транслятор определяет где метод, а где конструктор (см. пример выше)?

**Ответ.** У конструктора, в отличие от метода, нет типа возвращаемого значения.

**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html
 
Дан класс.
class Name {
	String name;
	Name() {
		this(makeRandomName());
	}
	Name(String name) {
		super();
		this.name = name;
	}
	String makeRandomName() {
		int k = (int) (Math.random() * 3);
		String name = new String[] {"Alpha", "Beta", "Gamma"}[k];
		return name;
	}
	public String toString() {
		return name;
	}
	public static void main(String[] args) {
		System.out.println(new Name());
	}
}
Объясните причину ошибки компиляции. 
Предложите минимум 2 способа исправления ошибки, использовать метод makeRandomName() обязательно.**

**Ответ.** Нельзя ссылаться на this до того, как будет создан экземпляр класса.
Способ 1. Сделать метод String makeRandomName() статическим.
Способ 2. Провести прямую инициализацию поля name в конструкторе без параметров:
name = makeRandomName();
Способ 3.
Name() {
	this(new Name("").makeRandomName());
}

Дан класс.
class Int {
	int i;
	void inc(Int param) {
		//param = new Int();
		param.i++;
	}
	public static void main(String[] args) {
		Int obj = new Int();
		obj.inc(obj);
		System.out.println(obj.i);
	}
}
Изменится ли результат, если убрать комментарий?
Объясните, почему?

В чем смысл конструкции this?
Перечислите случаи, когда используется конструкция this.
В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими возможностями. Если можно, то каким образом?

**Ответ.** this - это ссылка на текущий объект.
Конструкция this используется:
1) Для доступа к полям, перекрытым одноимёнными аргументами или локальными переменными метода или конструктора. Можно избежать использования this, используя разные имена для полей класса и  локальных данных.
2) Внутри конструктора для вызова другого конструктора этого же класса. Это называется явным вызовом конструктора. В этом случае можно избежать использования this() только путём дублирования кода.
3)  Для возврата ссылки на текущий объект (return this). Заменить нельзя.
4)  Операции с полями класса внутри логического блока до явного объявления этого поля возможны только при использовании ссылки  this, представляющую собой ссылку на текущий объект.
\**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html

**Можно ли присвоить null ссылочной переменной this?
Ответ.** Нет, компилятор этого не позволит, this объявлена как final. Будет ошибка компиляции.
**Источник.** http://www.java67.com/2013/06/difference-between-this-and-super-keyword-java.html

Перечислите случаи, когда используется статический блок?
В каких случаях можно обойтись без него. Если можно, то каким образом?

**Ответ.** Статический блок — это код, который вызывается только один раз в жизненном цикле приложения при загрузке класса. Может быть использован для:
●   	Выполнения некоторых начальных действий перед использованием класса (Например, вычислить какие-либо статические величины, собрать системные данные, подключиться к базе данных или удалённому серверу.)
●   	Инициализации статических переменных
Синтаксис статического блока:
static {
// Static block code
}
Загрузка класса инициируется:
- при создании объекта - вместо блока можно использовать вызов статического метода;
-  при обращении к статическому методу (полю) данного класса - аналогично;
- вызовом метода Class.forName(String className) - можно использовать вызов статического метода через ссылку, что является антипаттерном. Поэтому статический блок - это отличная альтернатива.

**Источник.**
https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html
 
Перечислите случаи, когда используется логический блок?
В каких случаях можно обойтись без него. Если можно, то каким образом?
 
Что входит в сигнатуру метода?
Ответ. Сигнатура метода – имя метода и список и тип его параметров (порядок важен).
Пример:
public double method(int n, String s)
public double method(String s, int n)
Эти методы имеют разные сигнатуры:
method(int, String) и  method(String, int) соответственно.
Источник. https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html

Что значит ключевое слово native?

**Ответ.** Модификатор native означает, что метод, к которому применено это ключевое слово, реализован не на языке Java и данный метод реализован в платформо-зависимом коде, часто на языке С. Этот модификатор может быть применен только к методам, но не классам и переменным.

**Источник.** “Полный справочник по Java”, Г. Шилд, Москва: издательский дом “Вильямс”,2007.

*Дан код. 
public class BusinessTrip {
  …
  public String bynToStr(int value) {
    return (value / 100) + "." + (value / 10 % 10) + (value % 10);
  }
}
Есть ли в нем семантическая ошибка?
Если да, то обоснуйте. 

**Ответ.** Да. Метод bynToStr(int value) должен быть статическим, так как работа метода не связана с отдельным экземпляром.

Дан код. 
public class Utility {
  private Utility() {
  }
  public String bynToStr(int value) {
    return (value / 100) + "." + (value / 10 % 10) + (value % 10);
  }
}
Есть ли в нем семантическая ошибка?
Если да, то предложите альтернативные варианты. 

К каким данным можно обратиться в статическом методе?

**Ответ.** В статическом методе можно обратиться:
●       к статическим членам класса;
●       к переменным, которые объявленные в этом методе;
●       к аргументам метода.

**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html

Почему нельзя объявить статическое поле внутри метода?
Почему нельзя объявить статическое поле внутри метода?

**Ответ.** Статическое поле принадлежит классу, а поля метода - самому методу вне зависимости от того, статичен он или нет. И если статическое поле создается один раз еще до создания хотя бы одного экземпляра класса и существует на протяжении всего времени выполнения программы, использующей данный класс, то поля метода - только во время исполнения метода и никогда до или после.

**Источник.** https://javarush.ru/groups/posts/800-10-zametok-o-modifikatore-static-v-java

Перечислите, какой код в классе можно выполнить до создания объекта.
 
В чем различие между объектом и экземпляром класса?
В чем различие между объектом и экземпляром класса?

**Ответ.** Термины «экземпляр класса» и «объект» взаимозаменяемы. Экземпляр класса (англ. instance) — это описание конкретного объекта в памяти. В большинстве объектно-ориентированных языков программирования (таких как Java), объекты являются экземплярами некоторого заранее описанного класса.

**Источник.** https://ru.wikipedia.org/wiki/Объект_(программирование)

Назовите три этапа создания экземпляра класса.

**Ответ.** Существует три этапа создания экземпляра класса:
1. Declaration − объявление переменной с типом объекта.
2. Instantiation − Ключевое слово 'new' используется для выделения памяти под объект, переменная получает ссылку на выделенную область памяти.
3. Initialization − вызов конструктора объекта

**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/objectcreation.html
 
Охарактеризуйте отношение композиции между классами? Как оно реализуется?

**Ответ.** Это отношение, при котором объект класса не только является частью объекта другого класса, но и вообще не может принадлежать еще какому-то классу. Реализуется путем создания ссылки в одном классе на другой.

**Источник.** http://java-course.ru/begin/relations/

Допустим, необходимо, чтобы метод возвращал два значения одного примитивного типа.
Предложите способы и подтвердите примерами.
Допустим, необходимо, чтобы метод возвращал два значения одного примитивного типа.
Предложите способы и подтвердите примерами.

**Ответ.** Способ 1:
// Примитивные массивы
public int[] method() {
    	   return new[]{1, 2};
}
Способ 2:
// Дополнительный класс
class Pair {
private int x;
 	private int y;
 
 	public Pair(int x, int y) {
	   	this.x = x;
	   	this.y = y;
}
}
public Pair method() {
    	   return new Pair(1, 2);
}
 
 
Допустим, необходимо, чтобы метод возвращал два значения разных примитивных типов.
Предложите способы и подтвердите примерами.

**Ответ.**
// Дополнительный класс
class Pair {
private int x;
 	private char y;
 
 	public Pair(int x, char y) {
	   	this.x = x;
	   	this.y = y;
 	}
}
public Pair method() {
return new Pair(1, 'a');
}
 
 

Что такое иммутабельный объект? 

**Ответ.** Неизменяемый объект – это объект, состояние которого не может быть изменено после создания. Здесь состоянием объекта по существу считаются значения, хранимые в экземпляре класса, будь то примитивные типы или ссылочные типы.

**Источник.** https://javarush.ru/groups/posts/765-java-core-voprosih-k-sobesedovaniju-ch-1
 

Опишите 2 способа создания иммутабельных объектов. 
Подсказка. Способ 1 - класс материала в classes2. 
Какой альтернативный? 
Подсказка - ключевое слово final для полей не использовать.
Создайте иммутабельный класс для вещества по альтернативному способу. 

**Ответ.** 1 - объявить поля объекта с модификатором final.
2 - просто исключить возможность изменять состояние объекта (не объявлять сеттеры и другие методы для изменения внутреннего состояния), а модифицирующие методы должны возвращать новые экземпляры класса.
public class Material {
 	private String name;
 	private double density;
 
 	public Material() {
	   	this(0.0, null);
 	}
 	public Material(double density, String name) {
	 this.density = density;
	 this.name = name;
 	}
 	public String getName() {
	   	return name;
 	}
 	public double getDensity() {
	   	return density;
 	}
}

**Источник.** https://docs.oracle.com/javase/tutorial/essential/concurrency/imstrat.html
 

Даны 2 класса.
final class Material {
	private final String name;
	private final double density;
	...
}
class Runner {
	private static void printMaterial(final Material material) {
        	System.out.println(material);
	}
	public static void main(String[] args) {
        	Material steel = new Material("steel",7850);
        	printMaterial(steel);
	}
}
В методе printMaterial() по ссылке material создается новый объект или имеется доступ к объекту new Material("steel",7850)? 
Какой пример можно использовать для обоснования ответа?

**Ответ.** В методе printMaterial()новый объект не создается, а создается копия final ссылки на тот же объект. Проверить равенство можем используя метод equals() класса Object, который сравнит ссылки наших объектов (можно было написать и ==). Использовать метод hashCode() для обоснования ответа мы не можем, т. к если хеш-коды равны, то входные объекты не всегда равны.
Пример:
final class Material {
    	private final String name;
    	private final double density;
    	...
}
class Runner {
  private static Material printMaterial(final Material material) {
   	System.out.println(material);
   	return material;
  }
  public static void main(String[] args) {
   	Material steel = new Material("steel",7850);
       System.out.println(printMaterial(steel).equals(steel));
  }
}

**Источник:** https://habr.com/post/168195/

Класс для комплексного числа содержит два поля:
class Complex {
	private double re;
	private double im;
	…
}
Реализуйте в данном классе методы: plus() для операции + и add() для +=.
Приведите пример использования каждого метода.
Реализуйте эти же методы при условии, что класс Complex является иммутабельным. 

Для чего предназначен метод toString()?
В каких случаях он вызывается?

**Ответ.** Возвращает строковое представление объекта. Как правило, toStringметод возвращает строку, которая «текстуально представляет» этот объект. В результате должно получиться краткое, но информативное представление, удобное для чтения. Рекомендуется, чтобы все подклассы переопределяли этот метод.

**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html

Как реализован метод toString() в классе Object?

**Ответ.** Метод equals() в классе Object реализован следующим образом:
 public boolean equals(Object obj) {
return (this == obj);
}
В данной реализации true возвращается лишь в случае, когда обе ссылки указывают на один и тот же объект.

**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object

Для чего предназначен метод equals()?
В каких случаях он вызывается?

**Ответ.** Метод public boolean equals(Object obj) используется для сравнения вызывающего его объекта с каким-либо другим объектом, указанным в качестве аргумента этого метода.
        	При этом, сравнение предполагает не проверку равенства ссылок на эти объекты, а проверку логической эквивалентности объектов (например, принадлежность объектов одному классу, равенство всех или части полей объектов).  Т.е. Он вызывается в случаях, необходимости проверки на логическое равенство объектов. Логика работы метода equals() должна соответствовать поставленной задаче, а также соглашениям, предусмотренным спецификацией языка:
Сравнение должно происходить в соответствии со следующими правилами:
- рефлексивность¬ объект должен быть равен самому себе;
- симметричность¬ если a.equals(b) = true, то и b.equals(a) всегда  возвращает true;
- транзитивность если x.equals(y), x.equals(z) = true, то и y.equals(z)  = true;
- непротиворечивость при многократном вызове метода для двух не подвергшихся         	     изменению объектов возвращаемое значение всегда должно быть одинаковым;
- ненулевая ссылка при сравнении с литералом null всегда возвращает false.

**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)

Как реализован метод equals() в классе Object?

**Ответ:** equalsМетод класса Objectреализует наиболее разборчивых возможное отношение эквивалентности на объектах; то есть для любых ненулевых ссылочных значений xи yэтот метод возвращает trueтогда и только тогда, когда xи yссылается на один и тот же объект ( x == yимеет значение true).
Обратите внимание, что обычно необходимо переопределить hashCode метод всякий раз, когда этот метод переопределяется, чтобы сохранить общий контракт для hashCodeметода, в котором говорится, что одинаковые объекты должны иметь одинаковые хэш-коды.

**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)

В чем различие между методом equals() и операции ==?
В каких случаях применение метода equals() и операции == эквивалентно?
**Ответ:** Отличия equals() от операции == в классе Object нет. Это видно, если взглянуть исходный код метода equals класса Object:

public boolean equals(Object obj) { 
    return (this == obj); 
} 
Однако, нужно не забывать, что, если объект ни на что не ссылается(null), то вызов метода equals этого объекта приведет к NullPointerException. Также нужно помнить, что при сравнении объектов оба они могут быть null и операция obj1 == obj2 в данном случае будет true, а вызов equals приведет к исключению NullPointerException.
Как мы видим, при помощи операции == сравниваются ссылки на объекты. Но мы можем переопределять метод equals, тем самым задавая логику сравнения двух объектов. Например, рассмотрим сравнение двух одинаковых чисел, созданных при помощи класса Integer:
Integer a = new Integer(6); 
Integer b = new Integer(6); 
// false т.к. это разные объекты с разными ссылками 
System.out.println(a == b);  
// true, здесь уже задействована логика сравнения 
System.out.println(a.equals(b));
Eclipse в стандартной конфигурации генерирует начало метода equals() следующим образом:
public boolean equals(Object obj) {
if (this == obj)
return true;
if (obj == null)
return false;

**Источник.** http://www.quizful.net/interview/java/equals-equality-difference

С чем связаны данные проверки, которые кажутся лишними?
 
Что такое garbage collection?

**Ответ.** Сборщик мусора — механизм, позволяющий автоматически освобождать память, занимаемую объектом. Когда никаких ссылок на объект не существует, т. е. все ссылки на него вышли из области видимости программы, предполагается, что объект больше не нужен, и память, занятая объектом, может быть освобождена. «Сборка мусора» происходит нерегулярно во время выполнения программы.

**Источник.** И. Блинов. Java. Методы программирования. с. 118.

Перечислите случаи, когда JVM отдает управление на garbage collector.

Как сделать так, чтобы JVM сразу перешла в режим сборки мусора?

Гарантирует ли garbage collector, что приложение в любом случае не будет иметь проблемы с недостатком памяти? 
Обоснуйте ответ.

Для чего предназначен метод finalize()?
Какой недостаток у метода?

**Ответ.** Данный метод автоматически вызывается сборщиком мусора перед уничтожением объекта. Запуск стандартного механизма finalization определяется алгоритмом сборки мусора, и до его непосредственного исполнения может пройти сколь угодно много времени. Из-за всего этого поведение метода finalize() может повлиять на корректную работу программы, особенно при смене JVM. Если существует возможность освободить ресурсы или выполнить другие подобные действия без привлечения этого механизма, то лучше без него обойтись. Виртуальная машина вызывает этот метод всегда, когда она собирается уничтожить объект данного класса. Внутри метода protected void finalize(), вызываемого непосредственно перед освобождением памяти, следует определить действия, которые должны быть выполнены до уничтожения объекта. Ключевое слово protected запрещает доступ к finalize() коду, определенному вне этого класса. Метод finalize() вызывается только перед самой «сборкой мусора», а не тогда, когда объект выходит из области видимости, т. е. Заранее невозможно определить, когда finalize() будет выполнен, и недоступный объект  может  занимать  память  довольно  долго.  В  принципе,  этот  метод  может быть вообще не выполнен! Недопустимо в приложении доверять такому методу критические по времени действия по освобождению ресурсов. Если не вызвать явно метод finalize() суперкласса, то он не будет вызван автоматически. Еще одна опасность: если при выполнении данного метода возникнет исключительная ситуация, она будет проигнорирована и приложение продолжит выполняться, что также представляет опасность для его корректной работы. Согласно Джошуа Блоху этот метод замедляет работу «сборщика мусора» в ~430 раз.

**Источник.** И. Блинов. Java. Методы программирования. с. 112, 118-120.

Для чего предназначены оболочечные классы?
Как они называются на инглише?

**Ответ.** Кроме базовых типов данных, в языке Java широко используются соответствующие классы-оболочки (wrapper-классы) из пакета java.lang: Boolean, Character, Integer, Byte, Short, Long, Float, Double. Объекты этих классов могут хранить те же значения, что и соответствующие им базовые типы. Объект любого из этих классов представляет собой полноценный экземпляр в динамической памяти, в котором хранится его неизменяемое значение.

**Источник.** И. Блинов. Java. Методы программирования. с. 40.

В чем преимущество примитивных типов перед соответствующими оболочечными классами? 

Что такое autoboxing и unboxing?

**Ответ.** Автоупаковка (autoboxing) и распаковка (unboxing) - это одно из существенных изменений, внесенных в JDK 5. Теперь разработчики могут писать более чистый код, но непонимание работы этого механизма может привести к плохой производительности.
Автоупаковка
Это процесс, в результате которого примитивный тип автоматически инкапсулируется (упаковывается) в эквивалентную ему оболочку типа всякий раз, когда требуется объект данного типа.
Autoboxing происходит:
●       При присвоении значения примитивного типа переменной соответствующего класса-обёртки.
●       При передаче примитивного типа в параметр метода, ожидающего соответствующий ему класс-обёртку.
Автораспаковка
Это процесс автоматического извлечения значения упакованного объекта (распаковки) из оболочки типа, когда нужно получить его значение.  Если при распаковке класс-обёртка был равен null, произойдет исключение java.lang.NullPointerException.
Unboxing происходит:
●       При присвоении экземпляра класса-обёртки переменной соответствующего примитивного типа.
●       В выражениях, в которых один или оба аргумента являются экземплярами классов-обёрток (кроме операции == и !=).
●       При передаче объекта класса-обёртки в метод, ожидающий соответствующий примитивный тип.

**Источник.** https://habr.com/post/329498/

Дан код:
Integer a = 3, b =7;
Long c = a + b;
Перечислите все операции, где задействованы autoboxing и unboxing.

**Ответ.** Строка Integer a = 3, b = 7; // Здесь происходит autoboxing из примитивного типа int к ссылочному Integer.
Строка Long c = a + b; // Здесь происходит unboxing из Integer в примитивный тип int для операции сложения (+), а затем результат подвергается autoboxing’у для приведения к ссылочному типу Long.

**Источник.** https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html
 

Дан корректный раннер-класс. 
Будет ли ошибка компиляции, если удалить модификатор static из сигнатуры метода main()? 
Обоснуйте ответ.
Что произойдет, если отправить на выполнение измененный класс?

**Ответ.** 
Сигнатура метода останется корректной, ошибки компиляции не будет.
При выполнении такого раннер-класса будет ошибка:
Error: Main method is not static in class Runner, please define the main method as:
public static void main(String[] args).
 

Дан класс.
class Runner {
	public static void main(String[] args) {
        	System.out.println("Hello, world!");
	}
}
Запрещается изменять синий код, т.е. метод main().
Добавить код в класс Runner, так чтобы в результате запуска этого класса из под JVM в консоли был следующий результат:
I am java.
Hello, world!
Ответ. 
class Runner {
static {
System.out.println("I am java.");
}
 	 public static void main(String[] args) {
System.out.println("Hello, world!");
 	 }
 }
 
Бонусное задание 1 (необязательное)
В задаче classes3 имеются два константных поля в классе покупки.
Им сразу присваиваются значения по умолчанию.
Например.
public class Purchase {
  public final static String PRODUCT_NAME = "milk";
  public final static int PRICE = 120;
  ...
}
Измените реализацию так, чтобы константы инициализировались значениями из текстового файла, находящемся в том же пакете, что и класс покупки. Имя файла - константа в классе покупки.
Если будет сбой с файлом или в нем будут недопустимые значения, то присвойте константам PRODUCT_NAME и PRICE значения по умолчанию.
Для этого же примера начало класса должно быть таким:
public class Purchase {
  private static final String PRODUCT_NAME;
  private static final int PRICE;
  public static final String FILE_NAME = "src/by/gsu/epamlab/constants.txt";
  private static final String DEFAULT_PRODUCT_NAME = "milk";
  private static final int DEFAULT_PRICE = 120;

